<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
    <title>实验楼Ubuntu课程笔记</title>
    <link type="text/css" rel="stylesheet" href="../assets/css/github-markdown.css">
    <link type="text/css" rel="stylesheet" href="../assets/css/pilcrow.css">
    <link type="text/css" rel="stylesheet" href="../assets/css/hljs-github.min.css"/>
  </head>
  <body>
    <article class="markdown-body"><h1 id="实验楼ubuntu课程笔记"><a class="header-link" href="#实验楼ubuntu课程笔记"></a>实验楼Ubuntu课程笔记</h1>
<h2 id="2-基本概念及操作"><a class="header-link" href="#2-基本概念及操作"></a>2 基本概念及操作</h2>
<ul class="list">
<li>Linux 默认提供了 6 个纯命令行界面的 “terminal”（准确的说这里应该是 6 个 virtual consoles）来让用户登录。在物理机系统上你可以通过使用[Ctrl]+[Alt]+[F1]～[F6]进行切换，当你切换到其中一个终端后想要切换回图形界面，你可以按下[Ctrl]+[Alt]+[F7]</li>
<li><p>终端快捷键</p>
<pre class="hljs"><code>  Ctrl+d 键盘输入结束或退出终端
  Ctrl+s 暂停当前程序，暂停后按下任意键恢复运行
  Ctrl+z 将当前程序放到后台运行，恢复到前台为命令fg
  Ctrl+a 将光标移至输入行头，相当于Home键
  Ctrl+e 将光标移至输入行末，相当于End键
  Ctrl+k 删除从光标所在位置到行末
  Alt+<span class="hljs-keyword">Backspace </span>向前删除一个单词
  <span class="hljs-keyword">Shift+PgUp </span>将终端显示向上滚动
  <span class="hljs-keyword">Shift+PgDn </span>将终端显示向下滚动</code></pre></li>
<li><p>通配符</p>
<pre class="hljs"><code>  字符  含义
  *   匹配 <span class="hljs-number">0</span> 或多个字符
  ?   匹配任意一个字符
  [list]  匹配 list 中的任意单一字符
  [!list] 匹配 除list 中的任意单一字符以外的字符
  [<span class="hljs-built_in">c1</span>-<span class="hljs-built_in">c2</span>] 匹配 <span class="hljs-built_in">c1</span>-<span class="hljs-built_in">c2</span> 中的任意单一字符 如：[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>] [a-z]
  {<span class="hljs-keyword">string1,string2,...} </span>  匹配 <span class="hljs-keyword">string1 </span>或 <span class="hljs-keyword">string2 </span>(或更多)其 一字符串
  {<span class="hljs-built_in">c1</span>..c2}    匹配 <span class="hljs-built_in">c1</span>-<span class="hljs-built_in">c2</span> 中全部字符 如{<span class="hljs-number">1</span>..<span class="hljs-number">10</span>}</code></pre></li>
<li><p>使用<code>man</code></p>
<ul class="list">
<li>通常 <code>man</code> 手册中的内容很多，你可能不太容易找到你想要的结果，不过幸运的是你可以在 <code>man</code> 中使用搜索<code>/&lt;你要搜索的关键字&gt;</code>，查找完毕后你可以使用<code>n</code>键切换到下一个关键字所在处，<code>shift+n</code>为上一个关键字所在处。使用<code>Space</code>（空格键）翻页，<code>Enter</code>（回车键）向下滚动一行，或者使用<code>j</code>,<code>k</code>（vim 编辑器的移动键）进行向前向后滚动一行。按下<code>h</code>键为显示使用帮助（因为 <code>man</code> 使用 <code>less</code> 作为阅读器，实为<code>less</code>工具的帮助），按下<code>q</code>退出。</li>
</ul>
</li>
</ul>
<h2 id="3-用户及文件权限管理"><a class="header-link" href="#3-用户及文件权限管理"></a>3 用户及文件权限管理</h2>
<ul class="list">
<li>who 命令其它常用参数<pre class="hljs"><code>  参数 说明
  -<span class="ruby">a 打印能打印的全部
</span>  -<span class="ruby">d 打印死掉的进程
</span>  -<span class="ruby">m 同am i,mom likes
</span>  -<span class="ruby">q 打印当前登录用户数及用户名
</span>  -<span class="ruby">u 打印当前登录用户登录信息
</span>  -<span class="ruby">r 打印运行等级</span></code></pre></li>
<li>创建用户<ul class="list">
<li><code>sudo adduser anna</code>, 这个命令不但可以添加用户到系统，同时也会默认为新用户创建 home 目录</li>
<li><code>su -l anna</code>, 切换登录用户</li>
</ul>
</li>
<li>用户组<ul class="list">
<li><code>groups jacktroy</code>, 显示用户组</li>
<li><code>sudo usermod -G sudo anna</code>, 将其它用户加入 sudo 用户组</li>
<li><code>/etc/group</code> 的内容包括用户组（Group）、用户组口令、GID 及该用户组所包含的用户（User），每个用户组一条记录。格式如下：<code>group_name:password:GID:user_list</code>, 密码显示x表示不可见</li>
</ul>
</li>
<li>删除用户<ul class="list">
<li><code>sudo deluser anna --remove-home</code>,</li>
</ul>
</li>
<li>变更文件所有者<ul class="list">
<li><code>sudo chown shiyanlou iphone6</code>, 新用户为<code>shiyanlou</code>，被修改的文件为<code>iphone6</code></li>
</ul>
</li>
<li>Linux 文件权限<ul class="list">
<li><code>ls -l</code>, 显示文件夹所有文件权限</li>
<li><code>ls -A</code>, 显示显示除了 .（当前目录）和 ..（上一级目录）之外的所有文件，包括隐藏文件（Linux 下以 . 开头的文件为隐藏文件</li>
<li><code>ll somefile</code> or <code>ll dir</code>, 显示该文件(夹)的权限</li>
<li><img src="3-1.png" alt="explanation 1"></li>
<li><img src="3-2.png" alt="explanation 2"></li>
<li>文件类型: 关于文件类型，这里有一点你必需时刻牢记 Linux 里面一切皆文件，正因为这一点才有了设备文件（ /dev 目录下有各种设备文件，大都跟具体的硬件设备相关）这一说。 socket：网络套接字，具体是什么，感兴趣的用户可以自己去了解或期待实验楼的后续相关课程。pipe 管道，这个东西很重要，我们以后将会讨论到，这里你先知道有它的存在即可。软链接文件：链接文件是分为两种的，另一种当然是“硬链接”（硬链接不常用，具体内容不作为本课程讨论重点，而软链接等同于 Windows 上的快捷方式,你记住这一点就够了）。</li>
<li>一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件</li>
<li><code>touch filename</code> 新建文件</li>
<li><code>cat</code> 查看文档</li>
<li>修改文件权限两种方式: 二进制, 加减赋值, 下面是二进制法<ul class="list">
<li><img src="3-3.png" alt="3-3"></li>
<li>每个文件的三组权限（拥有者，所属用户组，其他用户，记住这个顺序是一定的）对应一个 &quot; rwx &quot;，也就是一个 “ 7 ”</li>
<li><code>chmod 700 somefile</code>, 将拥有者设为7, 其他为0</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="4-linux-目录结构及文件基本操作"><a class="header-link" href="#4-linux-目录结构及文件基本操作"></a>4 Linux 目录结构及文件基本操作</h2>
<ul class="list">
<li>Filesystem Hierarchy Standard DOC<ul class="list">
<li><a href="http://refspecs.linuxfoundation.org/FHS_2.3/fhs-2.3.pdf">link</a></li>
<li><img src="4-1.png" alt="pic"></li>
</ul>
</li>
<li><code>-</code> 表示上一次所在目录，<code>~</code> 通常表示当前用户的 <code>home</code> 目录。使用 <code>pwd</code> 命令可以获取当前所在路径（绝对路径）</li>
<li><p>Linux 文件的基本操作</p>
<ul class="list">
<li><code>touch</code> 新建文件</li>
<li><code>mkdir</code> 新建目录</li>
<li><code>cp</code> 复制一个文件到指定目录， 使用 <code>-r</code> 复制目录及所有子项目</li>
<li><code>rm -f -r</code> 强制删除和递归删除所有子项目</li>
<li><code>mv</code>（move or rename files）命令移动文件（剪切），取决于后一个参数， 若为目录则移动， 若为新文件名则重命名</li>
<li><p><code>rename</code>, 重命名</p>
<pre class="hljs"><code><span class="hljs-comment">  # 使用通配符批量创建 5 个文件:</span>
  $ touch <span class="hljs-keyword">file</span>{<span class="hljs-number">1.</span><span class="hljs-number">.5</span>}.txt

<span class="hljs-comment">  # 批量将这 5 个后缀为 .txt 的文本文件重命名为以 .c 为后缀的文件:</span>
  $ <span class="hljs-keyword">rename</span> <span class="hljs-string">'s/\.txt/\.c/'</span> *.txt

<span class="hljs-comment">  # 批量将这 5 个文件，文件名改为大写:</span>
  $ <span class="hljs-keyword">rename</span> <span class="hljs-string">'y/a-z/A-Z/'</span> *.c

<span class="hljs-comment">  # 确认需要重命名的文件</span>
  <span class="hljs-keyword">rename</span> -n <span class="hljs-string">'s/Sam3/Stm32/'</span> *.nc
<span class="hljs-comment">  # 执行修改，并列出已重命名的文件</span>
  <span class="hljs-keyword">rename</span> -v <span class="hljs-string">'s/Sam3/Stm32/'</span> *.nc</code></pre><p>  rename 是先使用第二个参数的通配符匹配所有后缀为 .txt 的文件，然后使用第一个参数提供的正则表达式将匹配的这些文件的 .txt 后缀替换为 .c</p>
</li>
<li><p>使用 <code>cat</code>，<code>tac</code> 和 <code>nl</code> 命令查看文件，前两个命令都是用来打印文件内容到标准输出（终端）</p>
<ul class="list">
<li>其中 <code>cat</code> 为正序显示，<code>tac</code> 为倒序显示， 可以加上 -n 参数显示行号</li>
<li><code>nl</code> 命令，添加行号并打印，这是个比 <code>cat -n</code> 更专业的行号打印命令<pre class="hljs"><code>  -<span class="ruby">b : 指定添加行号的方式，主要有两种：
</span>      -<span class="ruby">b <span class="hljs-symbol">a:</span>表示无论是否为空行，同样列出行号(<span class="hljs-string">"cat -n"</span>就是这种方式)
</span>      -<span class="ruby">b <span class="hljs-symbol">t:</span>只列出非空行的编号并列出（默认为这种方式）
</span>  -<span class="ruby">n : 设置行号的样式，主要有三种：
</span>      -<span class="ruby">n <span class="hljs-symbol">ln:</span>在行号字段最左端显示
</span>      -<span class="ruby">n <span class="hljs-symbol">rn:</span>在行号字段最右边显示，且不加 <span class="hljs-number">0</span>
</span>      -<span class="ruby">n <span class="hljs-symbol">rz:</span>在行号字段最右边显示，且加 <span class="hljs-number">0</span>
</span>  -<span class="ruby">w : 行号字段占用的位数(默认为 <span class="hljs-number">6</span> 位)</span></code></pre></li>
</ul>
</li>
<li><code>more</code> <code>less</code> <code>head</code> <code>tail</code> 查看文件</li>
<li><code>file</code> 查看文件类型</li>
</ul>
</li>
</ul>
<h2 id="5-环境变量与文件查找"><a class="header-link" href="#5-环境变量与文件查找"></a>5 环境变量与文件查找</h2>
<ul class="list">
<li><code>declare</code> 命令创建一个变量名为 <code>tmp</code> 的变量</li>
<li>使用 <code>=</code> 号赋值运算符，将变量 <code>tmp</code> 赋值为 <code>$ tmp=jack</code></li>
<li>使用 <code>echo</code> 命令和 <code>$</code> 符号（<code>$</code> 符号用于表示引用一个变量)</li>
<li><p>环境变量</p>
<ul class="list">
<li>环境变量的作用域比自定义变量的要大，如 Shell 的环境变量作用于自身和它的子进程。</li>
<li>通常我们会涉及到的变量类型有三种：<ul class="list">
<li>当前 Shell 进程私有用户自定义变量，如上面我们创建的 tmp 变量，只在当前 Shell 中有效。</li>
<li>Shell 本身内建的变量。</li>
<li>从自定义变量导出的环境变量。</li>
</ul>
</li>
<li>也有三个与上述三种环境变量相关的命令：<code>set</code>，<code>env</code>，<code>export</code>, 三个命令很相似，都是用于打印环境变量信息<pre class="hljs"><code>  命 令    说 明
  <span class="hljs-keyword">set</span>     显示当前 Shell 所有变量，包括其内建环境变量（与<span class="hljs-comment"> Shell</span> 外观等相关），用户自定义变量及导出的环境变量
  env     显示与当前用户相关的环境变量，还可以让命令在指定环境中运行
  export 显示从<span class="hljs-comment"> Shell</span> 中导出成环境变量的变量，也能通过它<span class="hljs-comment">"将自定义变量导出为环境变量"</span><span class="hljs-comment">!!!</span></code></pre></li>
<li>关于哪些变量是环境变量，可以简单地理解成在当前进程的子进程有效则为环境变量，否则不是（有些人也将所有变量统称为环境变量，只是以全局环境变量和局部环境变量进行区分，我们只要理解它们的实质区别即可）</li>
<li>注意：为了与普通变量区分，通常我们习惯将环境变量名设为大写。</li>
<li>按变量的生存周期来划分，Linux 变量可分为两类：
  1.永久的：需要修改配置文件，变量永久生效；
  2.临时的：使用 <code>export</code> 命令行声明即可，变量在关闭 shell 时失效。</li>
<li><code>/etc/bashrc</code>（有的 Linux 没有这个文件） 和 <code>/etc/profile</code> ，它们分别存放的是 shell 变量和环境变量, 每个用户目录下的一个隐藏文件 <code>.profile</code> 只对当前用户永久生效, 而写在 <code>/etc/profile</code> 里面的是对所有用户永久生效</li>
<li>在每个用户的 home 目录中有一个 Shell 每次启动时会默认执行一个配置脚本，以初始化环境，包括添加一些用户自定义环境变量等等。zsh 的配置文件是 <code>.zshrc</code>，相应 Bash 的配置文件为 <code>.bashrc</code> 。它们在 etc 下还都有一个或多个全局的配置文件，不过我们一般只修改用户目录下的配置文件。</li>
<li>我们可以简单地使用下面命令直接添加内容到 .zshrc 中：<pre class="hljs"><code>  $ echo <span class="hljs-string">"PATH=$PATH:/home/shiyanlou/mybin"</span> <span class="hljs-meta">&gt;&gt; </span>.zshrc</code></pre></li>
<li>上述命令中 &gt;&gt; 表示将标准输出以追加的方式重定向到一个文件中，注意前面用到的 &gt; 是以覆盖的方式重定向到一个文件中</li>
<li>可以使用 <code>source</code> 命令来让修改后的文件立即生效</li>
</ul>
</li>
<li><p>搜索文件</p>
<ul class="list">
<li>与搜索相关的命令常用的有 <code>whereis</code>，<code>which</code>，<code>find</code> 和 <code>locate</code><ul class="list">
<li><code>whereis</code> 简单快速, 这个搜索很快，因为它并没有从硬盘中依次查找，而是直接从数据库中查询。whereis 只能搜索二进制文件(-b)，man 帮助文件(-m)和源代码文件(-s)。如果想要获得更全面的搜索结果可以使用 locate 命令。</li>
<li><code>locate</code> 快而全, 通过“ /var/lib/mlocate/mlocate.db ”数据库查找，不过这个数据库也不是实时更新的，系统会使用定时任务每天自动执行 <code>updatedb</code> 命令更新一次，所以有时候你刚添加的文件，它可能会找不到，需要手动执行一次 <code>updatedb</code> 命令（在我们的环境中必须先执行一次该命令）</li>
<li><code>which</code> 小而精, <code>which</code> 本身是 Shell 内建的一个命令，我们通常使用 <code>which</code> 来确定是否安装了某个指定的软件，因为它只从 <code>PATH</code> 环境变量指定的路径中去搜索命令：</li>
<li><code>find</code> 精而细, <code>find</code> 应该是这几个命令中最强大的了，它不但可以通过文件类型、文件名进行查找而且可以根据文件的属性（如文件的时间戳，文件的权限等）进行搜索。<pre class="hljs"><code>  sudo <span class="hljs-keyword">find</span> <span class="hljs-regexp">/etc/</span> -name interfaces
  # <span class="hljs-keyword">find</span> 目录 -name 名字， 以上命令表示去 <span class="hljs-regexp">/etc/</span> 目录下面 ，搜索名字叫做 interfaces 的文件或者目录</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-文件打包与解压缩"><a class="header-link" href="#7-文件打包与解压缩"></a>7  文件打包与解压缩</h2>
<ul class="list">
<li>常用的压缩包文件格式<pre class="hljs"><code>  文件后缀名 说明
  *<span class="hljs-selector-class">.zip</span> zip 程序打包压缩的文件
  *<span class="hljs-selector-class">.rar</span> rar 程序压缩的文件
  *.<span class="hljs-number">7</span>z <span class="hljs-number">7</span>zip 程序压缩的文件
  *<span class="hljs-selector-class">.tar</span> tar 程序打包，未压缩的文件
  *<span class="hljs-selector-class">.gz</span> gzip 程序（GNU zip）压缩的文件
  *<span class="hljs-selector-class">.xz</span> xz 程序压缩的文件
  *<span class="hljs-selector-class">.bz2</span> bzip2 程序压缩的文件
  *<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> tar 打包，gzip 程序压缩的文件
  *<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.xz</span> tar 打包，xz 程序压缩的文件
  *tar<span class="hljs-selector-class">.bz2</span> tar 打包，bzip2 程序压缩的文件
  *<span class="hljs-selector-class">.tar</span>.<span class="hljs-number">7</span>z tar 打包，<span class="hljs-number">7</span>z 程序压缩的文件</code></pre></li>
<li><p>zip 压缩打包程序</p>
<pre class="hljs"><code>  $ zip -r -<span class="hljs-number">9</span> -<span class="hljs-selector-tag">q</span> -o shiyanlou_9<span class="hljs-selector-class">.zip</span> /home/shiyanlou -x ~<span class="hljs-comment">/*.zip</span></code></pre><p>  第一行命令中，-r 参数表示递归打包包含子目录的全部内容，下一个参数用于设置压缩级别 -[1-9]，1 表   示最快压缩但体积大，9 表示体积最小但耗时最久, -q 参数表示为安静模式，即不向屏幕输出信息，-o，表   示输出文件，需在其后紧跟打包输出文件名, 最后那个 -x 是为了排除我们上一次创建的 zip 文件，否则又  会被打包进这一次的压缩文件中，注意：这里只能使用绝对路径，否则不起作用。</p>
<pre class="hljs"><code>  $ du -<span class="hljs-keyword">h</span> -<span class="hljs-keyword">d</span> 0 *.<span class="hljs-keyword">zip</span> ~ | <span class="hljs-keyword">sort</span></code></pre><p>  h， --human-readable（顾名思义，你可以试试不加的情况）, d， --max-depth（所查看文件的深度）</p>
<pre class="hljs"><code>  $ <span class="hljs-keyword">zip</span> -r -<span class="hljs-keyword">e</span> -o shiyanlou_encryption.<span class="hljs-keyword">zip</span> /home/shiyanlou</code></pre><p>  使用 -e 参数可以创建加密压缩包</p>
<pre class="hljs"><code>  $ <span class="hljs-keyword">zip</span> -r -<span class="hljs-keyword">l</span> -o shiyanlou.<span class="hljs-keyword">zip</span> /home/shiyanlou</code></pre><p>  需要加上 -l 参数将 LF 转换为 CR+LF 。</p>
<pre class="hljs"><code>  $ unzip -<span class="hljs-selector-tag">q</span> shiyanlou<span class="hljs-selector-class">.zip</span> -d ziptest</code></pre><p>  使用安静模式，将文件解压到指定目录</p>
<pre class="hljs"><code>  $ unzip <span class="hljs-_">-l</span> shiyanlou.zip</code></pre><p>  不想解压只想查看压缩包的内容你可以使用 -l 参数</p>
<pre class="hljs"><code>  <span class="hljs-variable">$ </span>unzip -O GBK 中文压缩文件.zip</code></pre><p>  使用 -O（英文字母，大写 o）参数指定编码类型</p>
</li>
<li><p>tar打包工具
  在 Linux 上面更常用的是 tar 工具，tar 原本只是一个打包工具，只是同时还是实现了对 7z、gzip、xz、bzip2 等工具的支持，这些压缩工具本身只能实现对文件或目录（单独压缩目录中的文件）的压缩，没有实现对文件的打包压缩</p>
<pre class="hljs"><code>  $ tar -cf shiyanlou<span class="hljs-selector-class">.tar</span> ~</code></pre><p>  创建一个 tar 包, -c 表示创建一个 tar 包文件，-f 用于指定创建的文件名，注意文件名必须紧跟在 -f 参数之后</p>
<pre class="hljs"><code>  <span class="hljs-variable">$ </span>mkdir tardir
  <span class="hljs-variable">$ </span>tar -xf shiyanlou.tar -C tardir</code></pre><p>  解包一个文件（-x 参数）到指定路径的已存在目录（-C 参数）</p>
<pre class="hljs"><code>  <span class="hljs-variable">$ </span>tar -tf shiyanlou.tar</code></pre><p>  只查看不解包文件 -t 参数</p>
<pre class="hljs"><code>  $ tar -cphf etc<span class="hljs-selector-class">.tar</span> /etc</code></pre><p>  保留文件属性和跟随链接（符号链接或软链接），有时候我们使用 tar 备份文件当你在其他主机还原时希望保留文件的属性（-p 参数）和备份链接指向的源文件而不是链接本身（-h 参数）</p>
<p>  对于创建不同的压缩格式的文件，对于 tar 来说是相当简单的，需要的只是换一个参数</p>
<pre class="hljs"><code>  压缩文件格式 参数
  *<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> -z
  *<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.xz</span> -J
  *tar<span class="hljs-selector-class">.bz2</span> -j</code></pre></li>
<li><p>常用命令：</p>
<pre class="hljs"><code>  zip：
  打包 ：zip something<span class="hljs-selector-class">.zip</span> something （目录请加 -r 参数）
  解包：unzip something
  指定路径：-d 参数
  tar：
  打包：tar -zcvf something<span class="hljs-selector-class">.tar</span> something
  解包：tar -zxvf something<span class="hljs-selector-class">.tar</span>
  指定路径：-C 参数</code></pre></li>
</ul>
<h2 id="8-文件系统操作与磁盘管理"><a class="header-link" href="#8-文件系统操作与磁盘管理"></a>8  文件系统操作与磁盘管理</h2>
<ul class="list">
<li>使用 df 命令查看磁盘的容量 <code>$ df</code></li>
<li>使用 du 命令查看目录的容量 <code>$ du</code>,</li>
<li><p>mount 命令</p>
<ul class="list">
<li><p>使用 <code>mount</code>来查看下主机已经挂载的文件系统</p>
<pre class="hljs"><code>$ mount
<span class="hljs-title">sysfs</span> on /sys <span class="hljs-class"><span class="hljs-keyword">type</span> sysfs (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>)</span>
<span class="hljs-title">proc</span> on /<span class="hljs-keyword">proc</span> <span class="hljs-class"><span class="hljs-keyword">type</span> proc (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>)</span>
<span class="hljs-title">udev</span> on /dev <span class="hljs-class"><span class="hljs-keyword">type</span> devtmpfs (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">size</span>=4008432<span class="hljs-title">k</span>,<span class="hljs-title">nr_inodes</span>=1002108,<span class="hljs-title">mode</span>=755)</span>
<span class="hljs-title">devpts</span> on /dev/pts <span class="hljs-class"><span class="hljs-keyword">type</span> devpts (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">gid</span>=5,<span class="hljs-title">mode</span>=620,<span class="hljs-title">ptmxmode</span>=000)</span>
<span class="hljs-title">tmpfs</span> on /run <span class="hljs-class"><span class="hljs-keyword">type</span> tmpfs (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">size</span>=806364<span class="hljs-title">k</span>,<span class="hljs-title">mode</span>=755)</span>
/dev/sda9 on / <span class="hljs-class"><span class="hljs-keyword">type</span> ext4 (<span class="hljs-title">rw</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">errors</span>=<span class="hljs-title">remount</span>-<span class="hljs-title">ro</span>,<span class="hljs-title">data</span>=<span class="hljs-title">ordered</span>)</span>
<span class="hljs-title">securityfs</span> on /sys/kernel/security <span class="hljs-class"><span class="hljs-keyword">type</span> securityfs (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>)</span>
<span class="hljs-title">tmpfs</span> on /dev/shm <span class="hljs-class"><span class="hljs-keyword">type</span> tmpfs (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>)</span>
<span class="hljs-title">tmpfs</span> on /run/lock <span class="hljs-class"><span class="hljs-keyword">type</span> tmpfs (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">size</span>=5120<span class="hljs-title">k</span>)</span>
<span class="hljs-title">tmpfs</span> on /sys/fs/cgroup <span class="hljs-class"><span class="hljs-keyword">type</span> tmpfs (<span class="hljs-title">ro</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">mode</span>=755)</span>
<span class="hljs-title">cgroup</span> on /sys/fs/cgroup/systemd <span class="hljs-class"><span class="hljs-keyword">type</span> cgroup (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">xattr</span>,<span class="hljs-title">release_agent</span>=/<span class="hljs-title">lib</span>/<span class="hljs-title">systemd</span>/<span class="hljs-title">systemd</span>-<span class="hljs-title">cgroups</span>-<span class="hljs-title">agent</span>,<span class="hljs-title">name</span>=<span class="hljs-title">systemd</span>)</span>
<span class="hljs-title">pstore</span> on /sys/fs/pstore <span class="hljs-class"><span class="hljs-keyword">type</span> pstore (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>)</span>
<span class="hljs-title">efivarfs</span> on /sys/firmware/efi/efivars <span class="hljs-class"><span class="hljs-keyword">type</span> efivarfs (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>)</span>
<span class="hljs-title">cgroup</span> on /sys/fs/cgroup/perf_event <span class="hljs-class"><span class="hljs-keyword">type</span> cgroup (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">perf_event</span>)</span>
<span class="hljs-title">cgroup</span> on /sys/fs/cgroup/freezer <span class="hljs-class"><span class="hljs-keyword">type</span> cgroup (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">freezer</span>)</span>
<span class="hljs-title">cgroup</span> on /sys/fs/cgroup/blkio <span class="hljs-class"><span class="hljs-keyword">type</span> cgroup (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">blkio</span>)</span>
<span class="hljs-title">cgroup</span> on /sys/fs/cgroup/net_cls,net_prio <span class="hljs-class"><span class="hljs-keyword">type</span> cgroup (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">net_cls</span>,<span class="hljs-title">net_prio</span>)</span>
<span class="hljs-title">cgroup</span> on /sys/fs/cgroup/devices <span class="hljs-class"><span class="hljs-keyword">type</span> cgroup (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">devices</span>)</span>
<span class="hljs-title">cgroup</span> on /sys/fs/cgroup/pids <span class="hljs-class"><span class="hljs-keyword">type</span> cgroup (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">pids</span>)</span>
<span class="hljs-title">cgroup</span> on /sys/fs/cgroup/cpu,cpuacct <span class="hljs-class"><span class="hljs-keyword">type</span> cgroup (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">cpu</span>,<span class="hljs-title">cpuacct</span>)</span>
<span class="hljs-title">cgroup</span> on /sys/fs/cgroup/memory <span class="hljs-class"><span class="hljs-keyword">type</span> cgroup (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">memory</span>)</span>
<span class="hljs-title">cgroup</span> on /sys/fs/cgroup/cpuset <span class="hljs-class"><span class="hljs-keyword">type</span> cgroup (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">cpuset</span>)</span>
<span class="hljs-title">cgroup</span> on /sys/fs/cgroup/hugetlb <span class="hljs-class"><span class="hljs-keyword">type</span> cgroup (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">noexec</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">hugetlb</span>)</span>
<span class="hljs-title">systemd</span><span class="hljs-number">-1</span> on /<span class="hljs-keyword">proc</span>/sys/fs/binfmt_misc <span class="hljs-class"><span class="hljs-keyword">type</span> autofs (<span class="hljs-title">rw</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">fd</span>=31,<span class="hljs-title">pgrp</span>=1,<span class="hljs-title">timeout</span>=0,<span class="hljs-title">minproto</span>=5,<span class="hljs-title">maxproto</span>=5,<span class="hljs-title">direct</span>)</span>
<span class="hljs-title">mqueue</span> on /dev/mqueue <span class="hljs-class"><span class="hljs-keyword">type</span> mqueue (<span class="hljs-title">rw</span>,<span class="hljs-title">relatime</span>)</span>
<span class="hljs-title">debugfs</span> on /sys/kernel/debug <span class="hljs-class"><span class="hljs-keyword">type</span> debugfs (<span class="hljs-title">rw</span>,<span class="hljs-title">relatime</span>)</span>
<span class="hljs-title">hugetlbfs</span> on /dev/hugepages <span class="hljs-class"><span class="hljs-keyword">type</span> hugetlbfs (<span class="hljs-title">rw</span>,<span class="hljs-title">relatime</span>)</span>
<span class="hljs-title">fusectl</span> on /sys/fs/fuse/connections <span class="hljs-class"><span class="hljs-keyword">type</span> fusectl (<span class="hljs-title">rw</span>,<span class="hljs-title">relatime</span>)</span>
/dev/sda10 on /home <span class="hljs-class"><span class="hljs-keyword">type</span> ext4 (<span class="hljs-title">rw</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">data</span>=<span class="hljs-title">ordered</span>)</span>
/dev/sda2 on /boot/efi <span class="hljs-class"><span class="hljs-keyword">type</span> vfat (<span class="hljs-title">rw</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">fmask</span>=0077,<span class="hljs-title">dmask</span>=0077,<span class="hljs-title">codepage</span>=437,<span class="hljs-title">iocharset</span>=<span class="hljs-title">iso8859</span>-1,<span class="hljs-title">shortname</span>=<span class="hljs-title">mixed</span>,<span class="hljs-title">errors</span>=<span class="hljs-title">remount</span>-<span class="hljs-title">ro</span>)</span>
<span class="hljs-title">binfmt_misc</span> on /<span class="hljs-keyword">proc</span>/sys/fs/binfmt_misc <span class="hljs-class"><span class="hljs-keyword">type</span> binfmt_misc (<span class="hljs-title">rw</span>,<span class="hljs-title">relatime</span>)</span>
<span class="hljs-title">tmpfs</span> on /run/user/<span class="hljs-number">1000</span> <span class="hljs-class"><span class="hljs-keyword">type</span> tmpfs (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">size</span>=806364<span class="hljs-title">k</span>,<span class="hljs-title">mode</span>=700,<span class="hljs-title">uid</span>=1000,<span class="hljs-title">gid</span>=1000)</span>
<span class="hljs-title">gvfsd</span>-fuse on /run/user/<span class="hljs-number">1000</span>/gvfs <span class="hljs-class"><span class="hljs-keyword">type</span> fuse.gvfsd-fuse (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">user_id</span>=1000,<span class="hljs-title">group_id</span>=1000)</span>
/dev/sda3 on /media/jacktroy/<span class="hljs-type">CS</span> <span class="hljs-class"><span class="hljs-keyword">type</span> fuseblk (<span class="hljs-title">rw</span>,<span class="hljs-title">nosuid</span>,<span class="hljs-title">nodev</span>,<span class="hljs-title">relatime</span>,<span class="hljs-title">user_id</span>=0,<span class="hljs-title">group_id</span>=0,<span class="hljs-title">default_permissions</span>,<span class="hljs-title">allow_other</span>,<span class="hljs-title">blksize</span>=4096,<span class="hljs-title">uhelper</span>=<span class="hljs-title">udisks2</span>)</span></code></pre><p>输出的结果中每一行表示一个设备或虚拟设备,每一行最前面是设备名，然后是 on 后面是挂载点，type 后面表示文件系统类型，再后面是挂载选项（比如可以在挂载时设定以只读方式挂载等等）</p>
<pre class="hljs"><code>mount <span class="hljs-comment">[-o <span class="hljs-comment">[操作选项]</span>]</span> <span class="hljs-comment">[-t 文件系统类型]</span> <span class="hljs-comment">[-w|--rw|--ro]</span> <span class="hljs-comment">[文件系统源]</span> <span class="hljs-comment">[挂载点]</span></code></pre><p>挂载硬盘</p>
<pre class="hljs"><code><span class="hljs-variable">$ </span>sudo umount /mnt</code></pre><p>使用 umount 命令从挂载点卸载已挂载磁盘</p>
<pre class="hljs"><code>$ sudo mkfs<span class="hljs-selector-class">.ext4</span> virtual.img</code></pre><p>使用 mkfs 命令格式化磁盘</p>
<pre class="hljs"><code><span class="hljs-meta"># 查看硬盘分区表信息</span>
$ sudo fdisk -l
<span class="hljs-meta"># 进入磁盘分区模式</span>
$ sudo fdisk <span class="hljs-keyword">virtual</span>.img</code></pre><p>使用 fdisk 为磁盘分区</p>
</li>
</ul>
</li>
</ul>
<h2 id="9-linux下的帮助命令"><a class="header-link" href="#9-linux下的帮助命令"></a>9  Linux下的帮助命令</h2>
<ul class="list">
<li><p>内建命令实际上是 shell 程序的一部分，其中包含的是一些比较简单的 Linux 系统命令，这些命令是写在bash源码的builtins里面的，并由 shell 程序识别并在 shell 程序内部完成运行，通常在 Linux 系统加载运行时 shell 就被加载并驻留在系统内存中。而且解析内部命令 shell 不需要创建子进程，因此其执行速度比外部命令快。比如：history、cd、exit 等等。</p>
</li>
<li><p>外部命令是 Linux 系统中的实用程序部分，因为实用程序的功能通常都比较强大，所以其包含的程序量也会很大，在系统加载时并不随系统一起被加载到内存中，而是在需要时才将其调用内存。虽然其不包含在 shell 中，但是其命令执行过程是由 shell 程序控制的。外部命令是在 Bash 之外额外安装的，通常放在/bin，/usr/bin，/sbin，/usr/sbin等等。比如：ls、vi等。</p>
</li>
<li><p>内建命令 <code>help exit</code>, 外部命令 <code>ls --help</code></p>
</li>
<li>获得更详细的帮助, <code>man ls</code>, <code>info ls</code></li>
</ul>
<h2 id="10-linux任务计划crontab"><a class="header-link" href="#10-linux任务计划crontab"></a>10  Linux任务计划crontab</h2>
<ul class="list">
<li><code>crontab</code> 命令常见于 Unix 和类 Unix 的操作系统之中（Linux 就属于类 Unix 操作系统），用于设置周期性被执行的指令。 <code>crontab</code> 储存的指令被守护进程激活， <code>crond</code> 为其守护进程，<code>crond</code> 常常在后台运行，每一分钟会检查一次是否有预定的作业需要执行。</li>
<li><p>使用命令 <code>crontab -e</code> 打开 <code>crontab</code> 脚本, 添加任务, 任务格式如下</p>
<pre class="hljs"><code>  # Example <span class="hljs-keyword">of</span> job <span class="hljs-keyword">definition</span>:
  # .---------------- minute (<span class="hljs-number">0</span> - <span class="hljs-number">59</span>)
  # |  .------------- hour (<span class="hljs-number">0</span> - <span class="hljs-number">23</span>)
  # |  |  .---------- day <span class="hljs-keyword">of</span> month (<span class="hljs-number">1</span> - <span class="hljs-number">31</span>)
  # |  |  |  .------- month (<span class="hljs-number">1</span> - <span class="hljs-number">12</span>) OR jan,feb,mar,apr ...
  # |  |  |  |  .---- day <span class="hljs-keyword">of</span> week (<span class="hljs-number">0</span> - <span class="hljs-number">6</span>) (Sunday=<span class="hljs-number">0</span> for <span class="hljs-number">7</span>) OR sun,mon,tue,wed,thu, fri,sat
  # |  |  |  |  |
  # f1 f2 f3 f4 f5 user-name command to be executed</code></pre><p>  其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程式。
  当 f1 为 <em> 时表示每分钟都要执行 program，f2 为 </em> 时表示每小时都要执行程式，其余类推
  当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其余类推
  当 f1 为 <em>/n 时表示每 n 分钟个时间间隔执行一次，f2 为 </em>/n 表示每 n 小时个时间间隔执行一次，其余类推
  当 f1 为 a, b, c,... 时表示第 a, b, c,... 分钟要执行，f2 为 a, b, c,... 时表示第 a, b, c...个小时要执行，其余类推
  使用者也可以将所有的设定先存放在档案 file 中，用 crontab file 的方式来设定时程表。
  例子:</p>
<pre class="hljs"><code>  每月每天每小时的第<span class="hljs-number"> 0 </span>分钟执行一次 /bin/ls :
 <span class="hljs-number"> 0 </span>* * * * /bin/ls

  在<span class="hljs-number"> 12 </span>月内, 每天的早上<span class="hljs-number"> 6 </span>点到<span class="hljs-number"> 12 </span>点中，每隔<span class="hljs-number"> 20 </span>分钟执行一次 /usr/bin/backup :
  */20 6-12 *<span class="hljs-number"> 12 </span>* /usr/bin/backup

  周一到周五每天下午 5:00 寄一封信给 alex_mail_name :
 <span class="hljs-number"> 0 </span>17 * * 1-5 mail -s "hi" alex_mail_name &lt; /tmp/maildata

  每月每天的午夜<span class="hljs-number"> 0 </span>点<span class="hljs-number"> 20 </span>分,<span class="hljs-number"> 2 </span>点<span class="hljs-number"> 20 </span>分,<span class="hljs-number"> 4 </span>点<span class="hljs-number"> 20 </span>分....执行 echo "haha"
 <span class="hljs-number"> 20 </span>0-23/2 * * * echo "haha"

  晚上11点到早上8点之间每两个小时，早上8点
 <span class="hljs-number"> 0 </span>23-7/2，8 * * * date

  创建以当前日期为文件名的文件
  */1 * * * * touch /home/shiyanlou/$(date +\%Y\%m\%d\%H\%M\%S)</code></pre><p>  关于 <code>date</code> 命令, <code>date</code> 能用来显示或设定系统的日期和时间，在显示方面，使用者能设定欲显示的格式，格式设定为一个加号后接数个标记.</p>
<p>  “ % ” 在 crontab 文件中，有结束命令行、换行、重定向的作用，前面加 ” \ ” 符号转意，否则，“ % ” 符号将执行其结束命令行或者换行的作用，并且其后的内容会被做为标准输入发送给前面的命令。</p>
</li>
</ul>
<ul class="list">
<li>使用命令 <code>crontab -l</code> 查询任务</li>
<li><p>检查 <code>crond</code> 是否在后台运行</p>
<pre class="hljs"><code>  <span class="hljs-variable">$ </span>ps aux | grep cron
  <span class="hljs-keyword">or</span>
  <span class="hljs-variable">$ </span>pgrep cron</code></pre></li>
<li><p>执行任务命令之后在,会在日志中的留下信息,使用命令查询 <code>sudo tail -f /var/log/syslog</code></p>
</li>
<li>不需要这个任务的时候我们可以使用这么一个命令去删除任务 <code>crontab -r</code></li>
<li><code>crontab</code> 深入<ul class="list">
<li>每个用户使用 <code>crontab -e</code> 添加计划任务，都会在 <code>/var/spool/cron/crontabs</code> 中添加一个该用户自己的任务文档，这样目的是为了隔离。</li>
<li>系统级别的定时任务, 只需要以 sudo 权限编辑 /etc/crontab</li>
<li>/etc/cron.daily，目录下的脚本会每天执行一次，在每天的6点25分时运行；</li>
<li>/etc/cron.hourly，目录下的脚本会每个小时执行一次，在每小时的17分钟时运行；</li>
<li>/etc/cron.monthly，目录下的脚本会每月执行一次，在每月1号的6点52分时运行；</li>
<li>/etc/cron.weekly，目录下的脚本会每周执行一次，在每周第七天的6点47分时运行；</li>
</ul>
</li>
</ul>
<h2 id="12-命令执行顺序控制与管道"><a class="header-link" href="#12-命令执行顺序控制与管道"></a>12  命令执行顺序控制与管道</h2>
<ul class="list">
<li>顺序执行多条命令，可以使用 <code>;</code> 来完成， i.e. <code>$ sudo apt-get update;sudo apt-get install some-tool;some-tool</code></li>
<li>有选择的执行命令, <code>&amp;&amp;</code> 表示如果前面的命令执行结果（不是表示终端输出的内容，而是表示命令执行状态的结果）返回0则执行后面的，否则不执行</li>
<li><code>||</code>在这里就是与<code>&amp;&amp;</code>相反的控制效果，当上一条命令执行结果为≠0($?≠0)时则执行它后面的命令</li>
<li><p>管道</p>
<ul class="list">
<li><code>|</code> ， 匿名管道</li>
<li><p><code>cut</code>, 打印每一行的某一字段</p>
<pre class="hljs"><code>  $ cut /etc/passwd <span class="hljs-_">-d</span> <span class="hljs-string">':'</span> <span class="hljs-_">-f</span> 1,6</code></pre><p>  打印/etc/passwd文件中以:为分隔符的第1个字段和第6个字段分别表示用户名和其家目录</p>
<pre class="hljs"><code>  <span class="hljs-comment"># 前五个（包含第五个）</span>
  $ cut <span class="hljs-regexp">/etc/</span>passwd -c -<span class="hljs-number">5</span>
  <span class="hljs-comment"># 前五个之后的（包含第五个）</span>
  $ cut <span class="hljs-regexp">/etc/</span>passwd -c <span class="hljs-number">5</span>-
  <span class="hljs-comment"># 第五个</span>
  $ cut <span class="hljs-regexp">/etc/</span>passwd -c <span class="hljs-number">5</span>
  <span class="hljs-comment"># 2到5之间的（包含第五个）</span>
  $ cut <span class="hljs-regexp">/etc/</span>passwd -c <span class="hljs-number">2</span>-<span class="hljs-number">5</span></code></pre><p>  打印/etc/passwd文件中每一行的前N个字符：</p>
</li>
<li><p><code>grep</code>, 一般形式为<code>grep [命令选项]... 用于匹配的表达式 [文件]...</code></p>
</li>
<li><code>wc</code> 命令用于统计并输出一个文件中行、单词和字节的数目<pre class="hljs"><code>  <span class="hljs-comment"># 行数</span>
  $ wc -l <span class="hljs-regexp">/etc/</span>passwd
  <span class="hljs-comment"># 单词数</span>
  $ wc -w <span class="hljs-regexp">/etc/</span>passwd
  <span class="hljs-comment"># 字节数</span>
  $ wc -c <span class="hljs-regexp">/etc/</span>passwd
  <span class="hljs-comment"># 字符数</span>
  $ wc -m <span class="hljs-regexp">/etc/</span>passwd
  <span class="hljs-comment"># 最长行字节数</span>
  $ wc -L <span class="hljs-regexp">/etc/</span>passwd</code></pre></li>
<li><p><code>sort</code> 排序命令</p>
<pre class="hljs"><code>  默认为字典排序：
  $ cat <span class="hljs-regexp">/etc/</span>passswd | <span class="hljs-keyword">sort</span>

  反转排序：
  $ cat <span class="hljs-regexp">/etc/</span>passwd | <span class="hljs-keyword">sort</span> -r

  按特定字段排序：
  $ cat <span class="hljs-regexp">/etc/</span>passwd | <span class="hljs-keyword">sort</span> -t<span class="hljs-string">':'</span> -k <span class="hljs-number">3</span>
  上面的-t参数用于指定字段的分隔符，这里是以<span class="hljs-string">":"</span>作为分隔符；-k 字段号用于指定对哪一个字段进行排序。
  这里<span class="hljs-regexp">/etc/</span>passwd文件的第三个字段为数字，默认情况下是以字典序排序的，如果要按照数字排序就要加上-n参数：
  $ cat <span class="hljs-regexp">/etc/</span>passwd | <span class="hljs-keyword">sort</span> -t<span class="hljs-string">':'</span> -k <span class="hljs-number">3</span> -n</code></pre></li>
<li><p><code>uniq</code> 去重命令, 只能去连续重复的行，不是全文去重
  我们可以使用 <code>history</code> 命令查看最近执行过的命令, 如果只想查看使用了那个命令而不需要知道具体干了什么，那么可以去掉命令后面的参数然后去掉重复的命令</p>
<pre class="hljs"><code>  $ <span class="hljs-built_in">history</span> | cut -c 8- | cut <span class="hljs-_">-d</span> <span class="hljs-string">' '</span> <span class="hljs-_">-f</span> 1 | sort | uniq</code></pre><p>  也可以输出重复行</p>
<pre class="hljs"><code>  <span class="hljs-comment"># 输出重复过的行（重复的只输出一个）及重复次数</span>
  $ <span class="hljs-built_in">history</span> | cut -c 8- | cut <span class="hljs-_">-d</span> <span class="hljs-string">' '</span> <span class="hljs-_">-f</span> 1 | sort | uniq -dc
  <span class="hljs-comment"># 输出所有重复的行</span>
  $ <span class="hljs-built_in">history</span> | cut -c 8- | cut <span class="hljs-_">-d</span> <span class="hljs-string">' '</span> <span class="hljs-_">-f</span> 1 | sort | uniq -D</code></pre></li>
</ul>
</li>
</ul>
<h2 id="13-简单的文本处理"><a class="header-link" href="#13-简单的文本处理"></a>13  简单的文本处理</h2>
<ul class="list">
<li><p><code>tr</code> 命令可以用来删除一段文本信息中的某些文字</p>
<pre class="hljs"><code>  -d 删除和set1匹配的字符，注意不是全词匹配也不是按字符顺序匹配
  -s 去除set1指定的在输入文本中连续并重复的字符

  # 删除 <span class="hljs-string">"hello shiyanlou"</span> 中所有的<span class="hljs-string">'o'</span>,<span class="hljs-string">'l'</span>,<span class="hljs-string">'h'</span>
  $ <span class="hljs-keyword">echo</span> <span class="hljs-string">'hello shiyanlou'</span> | <span class="hljs-keyword">tr</span> -d <span class="hljs-string">'olh'</span>
  # 将<span class="hljs-string">"hello"</span> 中的<span class="hljs-keyword">ll</span>,去重为一个<span class="hljs-keyword">l</span>
  $ <span class="hljs-keyword">echo</span> <span class="hljs-string">'hello'</span> | <span class="hljs-keyword">tr</span> -s <span class="hljs-string">'l'</span>
  # 将输入文本，全部转换为大写或小写输出
  $ <span class="hljs-keyword">cat</span> <span class="hljs-string">'input some text here'</span> | <span class="hljs-keyword">tr</span> <span class="hljs-string">'[:lower:]'</span> <span class="hljs-string">'[:upper:]'</span>
  # 上面的<span class="hljs-string">'[:lower:]'</span> <span class="hljs-string">'[:upper:]'</span>你也可以简单的写作<span class="hljs-string">'[a-z]'</span> <span class="hljs-string">'[A-Z]'</span>,当然反过来将大写变小写也是可以的</code></pre></li>
<li><p><code>col</code> 命令可以将Tab换成对等数量的空格键，或反转这个操作。</p>
<pre class="hljs"><code>  -<span class="ruby">x 将Tab转换为空格
</span>  -<span class="ruby">h 将空格转换为Tab（默认选项）</span></code></pre></li>
<li><p><code>join</code> 将两个文件中包含相同内容的那一行合并在一起, key可以由分隔符定义（类似数据库的join）</p>
<pre class="hljs"><code>  -<span class="ruby">t 指定分隔符，默认为空格
</span>  -<span class="ruby">i 忽略大小写的差异
</span>  -<span class="ruby"><span class="hljs-number">1</span> 指明第一个文件要用哪个字段来对比，默认对比第一个字段
</span>  -<span class="ruby"><span class="hljs-number">2</span> 指明第二个文件要用哪个字段来对比，默认对比第一个字段</span></code></pre></li>
<li><p><code>paste</code> 在不对比数据的情况下，简单地将多个文件合并一起，以Tab隔开。</p>
<pre class="hljs"><code>  使用方式：
  paste [option] file...

  常用的选项有：
  选项 说明
  -<span class="ruby">d 指定合并的分隔符，默认为Tab
</span>  -<span class="ruby">s 不合并到一行，每个文件为一行</span></code></pre></li>
</ul>
<h2 id="14-数据流重定向"><a class="header-link" href="#14-数据流重定向"></a>14  数据流重定向</h2>
<pre class="hljs"><code>文件描述符 设备文件 说明
<span class="hljs-number">0</span> /dev/<span class="hljs-built_in">stdin</span> 标准输入
<span class="hljs-number">1</span> /dev/<span class="hljs-built_in">stdout</span> 标准输出
<span class="hljs-number">2</span> /dev/<span class="hljs-built_in">stderr</span> 标准错误</code></pre><ul class="list">
<li><code>command &gt; file</code>, 命令的stdout重定位到文件</li>
<li><code>command &lt; file</code>, 文件作为命令的输入</li>
<li><code>&gt;&gt;</code>, stdout追加到一个文件的末端</li>
<li><code>&amp;&gt;</code>, stdout &amp; stderr 都重定位到文件</li>
<li><p><code>&gt;&amp;fd</code>, stdout 重定位到文件描述符</p>
<pre class="hljs"><code>  # 将标准错误重定向到标准输出，再将标准<span class="hljs-number">0</span>输出重定向到文件，注意要将重定向到文件写到前面
  $ cat Documents/test.<span class="hljs-keyword">c</span> hello.<span class="hljs-keyword">c</span> &gt;somefile  <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span>
  # 或者只用bash提供的特殊的重定向符号<span class="hljs-string">"&amp;"</span>将标准错误和标准输出同时重定向到文件
  $ cat Documents/test.<span class="hljs-keyword">c</span> hello.<span class="hljs-keyword">c</span> &amp;&gt;somefilehell</code></pre><p>  注意你应该在输出重定向文件描述符前加上&amp;,否则shell会当做重定向到一个文件名为1的文件中</p>
</li>
<li><p><code>tee</code>， 将输出重定向到文件,也将信息打印在终端， i.e. <code>$ echo &#39;hello shiyanlou&#39; | tee hello</code></p>
</li>
<li><code>exec</code> 命令的作用是使用指定的命令替换当前的 Shell，及使用一个进程替换当前进程，或者指定新的重定向<pre class="hljs"><code>  <span class="hljs-comment"># 先开启一个子 Shell</span>
  $ zsh
  <span class="hljs-comment"># 使用exec替换当前进程的重定向，将标准输出重定向到一个文件</span>
  $ exec <span class="hljs-number">1</span>&gt;somefile
  <span class="hljs-comment"># 后面你执行的命令的输出都将被重定向到文件中,直到你退出当前子shell，或取消exec的重定向（后面将告诉你怎么做）</span>
  $ ls
  $ <span class="hljs-keyword">exit</span>
  $ cat somefile</code></pre></li>
<li>可以使用下面命令查看当前 Shell 进程中打开的文件描述符：<code>$ cd /dev/fd/;ls -Al</code></li>
<li><p>使用 <code>exec</code> 命令可以创建新的文件描述符：</p>
<pre class="hljs"><code>  $ <span class="hljs-built_in">exec</span> 3&gt;somefile
  <span class="hljs-comment"># 先进入目录，再查看，否则你可能不能得到正确的结果，然后再回到上一次的目录</span>
  $ <span class="hljs-built_in">cd</span> /dev/fd/;ls -Al;<span class="hljs-built_in">cd</span> -
  <span class="hljs-comment"># 注意下面的命令&gt;与&amp;之间不应该有空格，如果有空格则会出错</span>
  $ <span class="hljs-built_in">echo</span> <span class="hljs-string">"this is test"</span> &gt;&amp;3
  $ cat somefile
  $ <span class="hljs-built_in">exit</span></code></pre></li>
<li><p>关闭上面打开的文件描述符， <code>$ exec 3&gt;&amp;-</code></p>
</li>
<li><p>屏蔽命令的输出</p>
<ul class="list">
<li>在类 UNIX 系统中，/dev/null，或称空设备，是一个特殊的设备文件，它通常被用于丢弃不需要的输出流，或作为用于输入流的空文件，这些操作通常由重定向完成。读取它则会立即得到一个EOF</li>
<li>我们可以利用设个/dev/null屏蔽命令的输出：<code>$ cat Documents/test.c nefile 1&gt;/dev/null 2&gt;&amp;1</code></li>
</ul>
</li>
<li><p>ex: 现在有一些命令的记录（来自<code>history</code>），现在需要你从里面找出出现频率次数前3的命令
  <code>$ cut data1 -c 8- | cut -d &#39; &#39; -f 1 | sort | uniq -dc | sort -k 1 -n -r | head -n 3</code></p>
</li>
</ul>
<h2 id="16-正则表达式基础"><a class="header-link" href="#16-正则表达式基础"></a>16  正则表达式基础</h2>
<ul class="list">
<li>regex 基本语法</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">\</td>
<td style="text-align:left">将下一个字符标记为一个特殊字符、或一个原义字符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。序列“\”匹配“\”而“(”则匹配“(”。</td>
</tr>
<tr>
<td style="text-align:left">^</td>
<td style="text-align:left">匹配输入字符串的开始位置。</td>
</tr>
<tr>
<td style="text-align:left">$</td>
<td style="text-align:left">匹配输入字符串的结束位置。</td>
</tr>
<tr>
<td style="text-align:left">{n}</td>
<td style="text-align:left">n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td>
</tr>
<tr>
<td style="text-align:left">{n,}</td>
<td style="text-align:left">n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td>
</tr>
<tr>
<td style="text-align:left">{n,m}</td>
<td style="text-align:left">m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空  格。</td>
</tr>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">匹配前面的子表达式零次或多次。例如，zo<em>能匹配“z”、“zo”以及“zoo”。</em>等价于{0,}。</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</td>
</tr>
<tr>
<td style="text-align:left">?</td>
<td style="text-align:left">当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。</td>
</tr>
<tr>
<td style="text-align:left">.</td>
<td style="text-align:left">匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.｜\n)”的模式。</td>
</tr>
<tr>
<td style="text-align:left">(pattern)</td>
<td style="text-align:left">匹配pattern并获取这一匹配的子字符串。该子字符串用于向后引用。要匹配圆括号字符，请使用“(”或“)”。</td>
</tr>
<tr>
<td style="text-align:left">x｜y</td>
<td style="text-align:left">匹配x或y。例如，“z｜food”能匹配“z”或“food”。“(z｜f)ood”则匹配“zood”或“food”。</td>
</tr>
<tr>
<td style="text-align:left">[xyz]</td>
<td style="text-align:left">字符集合（character class）。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。其中特殊字符仅有反斜线\保持特殊含义，用于转义字符。其它特殊字符如星号、加号、各种括号均作为普通字符。脱字符^如果出现在首位则表示负值字符集合；如果出现在字符串中间就仅作为普通字符。连字符 - 如果出现在字符串中间表示字符范围描   述；如果如果出现在首位则仅作为普通字符。</td>
</tr>
<tr>
<td style="text-align:left">[^xyz]</td>
<td style="text-align:left">排除型（negate）字符集合。匹配未列出的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</td>
</tr>
<tr>
<td style="text-align:left">[a-z]</td>
<td style="text-align:left">字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。</td>
</tr>
<tr>
<td style="text-align:left">[^a-z]</td>
<td style="text-align:left">排除型的字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td>
</tr>
</tbody>
</table>
<ul class="list">
<li>优先级为从上到下从左到右，依次降低：</li>
</ul>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>转义符</td>
</tr>
<tr>
<td>(), (?:), (?=), []</td>
<td>括号和中括号</td>
</tr>
<tr>
<td>*、+、?、{n}、{n,}、{n,m}</td>
<td>限定符</td>
</tr>
<tr>
<td>^、$、\任何元字符</td>
<td>定位点和序列</td>
</tr>
<tr>
<td>｜</td>
<td>选择</td>
</tr>
</tbody>
</table>
<ul class="list">
<li><p><code>grep</code> 命令</p>
<ul class="list">
<li><p>参数说明</p>
<pre class="hljs"><code>  参数 说明
  -<span class="ruby">b 将二进制文件作为文本来进行匹配
</span>  -<span class="ruby">c 统计以模式匹配的数目
</span>  -<span class="ruby">i 忽略大小写
</span>  -<span class="ruby">n 显示匹配文本所在行的行号
</span>  -<span class="ruby">v 反选，输出不匹配行的内容
</span>  -<span class="ruby">r 递归匹配查找
</span>  -<span class="ruby">A n n为正整数，表示after的意思，除了列出匹配行之外，还列出后面的n行
</span>  -<span class="ruby">B n n为正整数，表示before的意思，除了列出匹配行之外，还列出前面的n行
</span>  -<span class="ruby">-color=auto 将输出中的匹配项设置为自动颜色显示</span></code></pre></li>
<li><p>使用基本正则表达式，BRE如下</p>
</li>
<li><p>位置，查找/etc/group文件中以&quot;shiyanlou&quot;为开头的行</p>
<pre class="hljs"><code>  $ <span class="hljs-keyword">grep</span> <span class="hljs-string">'shiyanlou'</span> <span class="hljs-regexp">/etc/g</span>roup
  $ <span class="hljs-keyword">grep</span> <span class="hljs-string">'^shiyanlou'</span> <span class="hljs-regexp">/etc/g</span>roup</code></pre></li>
<li><p>数量</p>
<pre class="hljs"><code>  # 将匹配以<span class="hljs-string">'z'</span>开头以<span class="hljs-string">'o'</span>结尾的所有字符串！！！！
  $ <span class="hljs-keyword">echo</span> <span class="hljs-string">'zero\nzo\nzoo'</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">'z.*o'</span>
  # 将匹配以<span class="hljs-string">'z'</span>开头以<span class="hljs-string">'o'</span>结尾，中间包含一个任意字符的字符串
  $ <span class="hljs-keyword">echo</span> <span class="hljs-string">'zero\nzo\nzoo'</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">'z.o'</span>
  # 将匹配以<span class="hljs-string">'z'</span>开头,以任意多个<span class="hljs-string">'o'</span>结尾的字符串
  $ <span class="hljs-keyword">echo</span> <span class="hljs-string">'zero\nzo\nzoo'</span> | <span class="hljs-keyword">grep</span> <span class="hljs-string">'zo*'</span></code></pre></li>
<li><p>选择, 结果以颜色标注</p>
<pre class="hljs"><code>  <span class="hljs-comment"># grep默认是区分大小写的，这里将匹配所有的小写字母</span>
  $ <span class="hljs-built_in">echo</span> <span class="hljs-string">'1234\nabcd'</span> | grep <span class="hljs-string">'[a-z]'</span>
  <span class="hljs-comment"># 将匹配所有的数字</span>
  $ <span class="hljs-built_in">echo</span> <span class="hljs-string">'1234\nabcd'</span> | grep <span class="hljs-string">'[0-9]'</span>
  <span class="hljs-comment"># 将匹配所有的数字</span>
  $ <span class="hljs-built_in">echo</span> <span class="hljs-string">'1234\nabcd'</span> | grep <span class="hljs-string">'[[:digit:]]'</span>
  <span class="hljs-comment"># 将匹配所有的小写字母</span>
  $ <span class="hljs-built_in">echo</span> <span class="hljs-string">'1234\nabcd'</span> | grep <span class="hljs-string">'[[:lower:]]'</span>
  <span class="hljs-comment"># 将匹配所有的大写字母</span>
  $ <span class="hljs-built_in">echo</span> <span class="hljs-string">'1234\nabcd'</span> | grep <span class="hljs-string">'[[:upper:]]'</span>
  <span class="hljs-comment"># 将匹配所有的字母和数字，包括0-9,a-z,A-Z</span>
  $ <span class="hljs-built_in">echo</span> <span class="hljs-string">'1234\nabcd'</span> | grep <span class="hljs-string">'[[:alnum:]]'</span>
  <span class="hljs-comment"># 将匹配所有的字母</span>
  $ <span class="hljs-built_in">echo</span> <span class="hljs-string">'1234\nabcd'</span> | grep <span class="hljs-string">'[[:alpha:]]'</span></code></pre></li>
<li><p>下面包含完整的特殊符号及说明：</p>
<pre class="hljs"><code>  特殊符号 说明
  <span class="hljs-comment">[:alnum:]</span> 代表英文大小写字母及数字，亦即 0-9, A-Z, a-z
  <span class="hljs-comment">[:alpha:]</span> 代表任何英文大小写字母，亦即 A-Z, a-z
  <span class="hljs-comment">[:blank:]</span> 代表空白键与 <span class="hljs-comment">[Tab]</span> 按键两者
  <span class="hljs-comment">[:cntrl:]</span> 代表键盘上面的控制按键，亦即包括 CR, LF, Tab, Del.. 等等
  <span class="hljs-comment">[:digit:]</span> 代表数字而已，亦即 0-9
  <span class="hljs-comment">[:graph:]</span> 除了空白字节 (空白键与 <span class="hljs-comment">[Tab]</span> 按键) 外的其他所有按键
  <span class="hljs-comment">[:lower:]</span> 代表小写字母，亦即 a-z
  <span class="hljs-comment">[:print:]</span> 代表任何可以被列印出来的字符
  <span class="hljs-comment">[:punct:]</span> 代表标点符号 (punctuation symbol)，亦即：<span class="hljs-string">" ' ? ! ; : # $...
  <span class="hljs-subst">[:upper:]</span> 代表大写字母，亦即 A-Z
  <span class="hljs-subst">[:space:]</span> 任何会产生空白的字符，包括空白键, <span class="hljs-subst">[Tab]</span>, CR 等等
  <span class="hljs-subst">[:xdigit:]</span> 代表 16 进位的数字类型，因此包括： 0-9, A-F, a-f 的数字与字节</span></code></pre><p>  注意：之所以要使用特殊符号，是因为上面的[a-z]不是在所有情况下都管用，这还与主机当前的语系有关，即设置在LANG环境变量的值，zh_CN.UTF-8的话[a-z]，即为所有小写字母，其它语系可能是大小写交替的如，&quot;a A b B...z Z&quot;，[a-z]中就可能包含大写字母。所以在使用[a-z]时请确保当前语系的影响，使用[:lower:]则不会有这个问题。</p>
</li>
<li><p>排除字符，<code>$ echo &#39;geek\ngood&#39; | grep &#39;[^o]&#39;</code>， 注意:当^放到中括号内为排除字符，否则表示行首。</p>
</li>
<li><p>使用扩展正则表达式，ERE如下</p>
<p>  要通过grep使用扩展正则表达式需要加上-E参数，或使用egrep</p>
<ul class="list">
<li>数量<pre class="hljs"><code>  # 只匹配<span class="hljs-string">"zo"</span>
  $ <span class="hljs-keyword">echo</span> <span class="hljs-string">'zero\nzo\nzoo'</span> | <span class="hljs-keyword">grep</span> -E <span class="hljs-string">'zo{1}'</span>
  # 匹配以<span class="hljs-string">"zo"</span>开头单词，<span class="hljs-keyword">o</span>的数量大于等于<span class="hljs-number">1</span>
  $ <span class="hljs-keyword">echo</span> <span class="hljs-string">'zero\nzo\nzoo'</span> | <span class="hljs-keyword">grep</span> -E <span class="hljs-string">'zo{1,}'</span></code></pre>  注意：推荐掌握{n,m}即可，+,?,*，这几个不太直观，且容易弄混淆。</li>
<li>选择<pre class="hljs"><code>  # 匹配<span class="hljs-string">"www.shiyanlou.com"</span>和<span class="hljs-string">"www.google.com"</span>
  $ echo <span class="hljs-symbol">'www</span>.shiyanlou.com\nwww.baidu.com\nwww.google.com' | grep -<span class="hljs-type">E</span>     <span class="hljs-symbol">'www</span>\.      (shiyanlou|google)\.com'
  # 或者匹配不包含<span class="hljs-string">"baidu"</span>的内容
  $ echo <span class="hljs-symbol">'www</span>.shiyanlou.com\nwww.baidu.com\nwww.google.com' | grep -<span class="hljs-type">Ev</span>        <span class="hljs-symbol">'www</span>\.baidu\.com'</code></pre>  注意：因为.号有特殊含义，所以需要转义。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>sed</code> 流编辑器</p>
<pre class="hljs"><code>  sed [参数]... [执行命令] [输入文件]...
  # 形如：
  $ sed -i <span class="hljs-string">'1s/sad/happy/'</span> test # 表示将test文件中第一行的<span class="hljs-string">"sad"</span>替换为<span class="hljs-string">"happy"</span></code></pre></li>
<li><p><code>awk</code> 文本处理语言</p>
</li>
</ul>
<h2 id="18-linux下软件安装"><a class="header-link" href="#18-linux下软件安装"></a>18  Linux下软件安装</h2>
<p>通常 Linux 上的软件安装主要有四种方式：</p>
<ol class="list">
<li>在线安装</li>
<li>从磁盘安装deb软件包</li>
<li>从二进制软件包安装</li>
<li><p>从源代码编译安装</p>
</li>
<li><p>apt包管理工具, 在线安装</p>
<ul class="list">
<li>当你在执行安装操作时，首先apt-get 工具会在本地的一个数据库中搜索关于 w3m 软件的相关信息，并根据这些信息在相关的服务器上下载软件安装</li>
<li>需要定期从服务器上下载一个软件包列表，使用 sudo apt-get update 命令来保持本地的软件包列表是最新的（有时你也需要手动执行这个操作，比如更换了软件源），而这个表里会有软件依赖信息的记录</li>
<li><p><code>apt-get</code></p>
<pre class="hljs"><code>  工具 说明
  install 其后加上软件包名，用于安装一个软件包
  update 从软件源镜像服务器上下载/更新用于更新本地软件源的软件包列表
  upgrade 升级本地可更新的全部软件包，但存在依赖问题时将不会升级，通常会在更新之前执行一次        update
  dist-upgrade 解决依赖关系并升级(存在一定危险性)
  remove 移除已安装的软件包，包括与被移除软件包有依赖关系的软件包，但不包含软件包的配置文件
  autoremove 移除之前被其他软件包依赖，但现在不再被使用的软件包
  purge 与remove相同，但会完全移除软件包，包含其配置文件
  clean 移除下载到本地的已经安装的软件包，默认保存在/var/cache/apt/archives/
  autoclean 移除已安装的软件的旧版本软件包

  参数 说明
  -<span class="ruby">y 自动回应是否安装软件包的选项，在一些自动化安装脚本中使用这个参数将十分有用
</span>  -<span class="ruby">s 模拟安装
</span>  -<span class="ruby">q 静默安装方式，指定多个q或者-q=<span class="hljs-comment">#,#表示数字，用于设定静默级别，这在你不想要在安装软件包时     屏幕输出过多时很有用</span>
</span>  -<span class="ruby">f 修复损坏的依赖关系
</span>  -<span class="ruby">d 只下载不安装
</span>  -<span class="ruby">-reinstall 重新安装已经安装但可能存在问题的软件包
</span>  -<span class="ruby">-install-suggests 同时安装APT给出的建议安装的软件包</span></code></pre></li>
<li><code>apt-cache</code><ul class="list">
<li>软件搜索,当自己刚知道了一个软件，想下载使用，需要确认软件仓库里面有没有，就需要用到搜索功能了, <code>sudo apt-cache search softname1 softname2 softname3……</code></li>
</ul>
</li>
</ul>
</li>
<li><p>dpkg从本地磁盘安装 deb 软件包</p>
<ul class="list">
<li>以deb形式打包的软件包，就需要使用dpkg命令来安装<pre class="hljs"><code>参数 说明
-<span class="ruby">i 安装指定deb包
</span>-<span class="ruby">R 后面加上目录名，用于安装该目录下的所有deb安装包
</span>-<span class="ruby">r remove，移除某个已安装的软件包
</span>-<span class="ruby">I 显示deb包文件的信息
</span>-<span class="ruby">s 显示已安装软件的信息
</span>-<span class="ruby">S 搜索已安装的软件包
</span>-<span class="ruby">L 显示已安装软件包的目录信息</span></code></pre></li>
</ul>
</li>
</ol>
<h2 id="19-linux-进程概念"><a class="header-link" href="#19-linux-进程概念"></a>19  Linux 进程概念</h2>
<ul class="list">
<li><p>Session 主要是针对一个 tty 建立，Session 中的每个进程都称为一个工作(job)。每个会话可以连接一个终端(control terminal)。当控制终端有输入输出时，都传递给该会话的前台进程组。Session 意义在于将多个 jobs 囊括在一个终端，并取其中的一个 job 作为前台，来直接接收该终端的输入输出以及终端信号。 其他 jobs 在后台运行。</p>
<ul class="list">
<li>前台（foreground）就是在终端中运行，能与你有交互的</li>
<li>后台（background）就是在终端中运行，但是你并不能与其任何的交互，也不会显示其执行的过程</li>
</ul>
</li>
<li><p>工作管理</p>
<ul class="list">
<li><code>command &amp;</code> 令job在后台工作</li>
<li><code>ctrl + z</code> 使工作停止</li>
<li><code>fg [jobnumber]</code> 使job回到前台运行</li>
<li><code>bg [jobnumber]</code>使工作在后台运行</li>
<li><code>jobs</code> 查看后台的工作</li>
<li><code>kill -signal jobnumber</code>, 发送信号给工作<pre class="hljs"><code>  信号值 作用
  -<span class="ruby"><span class="hljs-number">1</span> 重新读取参数运行，类似与restart
</span>  -<span class="ruby"><span class="hljs-number">2</span> 如同 ctrl+c 的操作退出　
</span>  -<span class="ruby"><span class="hljs-number">9</span> 强制终止该任务　　　
</span>  -<span class="ruby"><span class="hljs-number">15</span> 正常的方式终止该任务</span></code></pre></li>
</ul>
</li>
</ul>
<h2 id="20-linux-进程管理"><a class="header-link" href="#20-linux-进程管理"></a>20  Linux 进程管理</h2>
<ul class="list">
<li><p><code>top</code> 工具是我们常用的一个查看工具，能实时的查看我们系统的一些关键信息的变化
  top 显示的第一排</p>
<pre class="hljs"><code>  内容 解释
  <span class="hljs-selector-tag">top</span> 表示当前程序的名称
  11<span class="hljs-selector-pseudo">:05</span><span class="hljs-selector-pseudo">:18</span> 表示当前的系统的时间
  <span class="hljs-selector-tag">up</span> 8 <span class="hljs-selector-tag">days</span>,17<span class="hljs-selector-pseudo">:12</span> 表示该机器已经启动了多长时间
  1 <span class="hljs-selector-tag">user</span> 表示当前系统中只有一个用户
  <span class="hljs-selector-tag">load</span> <span class="hljs-selector-tag">average</span>: 0<span class="hljs-selector-class">.29</span>,0<span class="hljs-selector-class">.20</span>,0<span class="hljs-selector-class">.25</span> 分别对应1、5、15分钟内<span class="hljs-selector-tag">cpu</span>的平均负载</code></pre><p>  在实际生活中，比较有经验的运维或者系统管理员会将临界值定为0.7。这里的指数都是除以核心数以后的值，不要混淆了</p>
<p>  若是 load &lt; 0.7 并不会去关注他；
  若是 0.7&lt; load &lt; 1 的时候我们就需要稍微关注一下了，虽然还可以应付但是这个值已经离临界不远了；
  若是 load = 1 的时候我们就需要警惕了，因为这个时候已经没有更多的资源的了，已经在全力以赴了；
  若是 load &gt; 5 的时候系统已经快不行了，这个时候你需要加班解决问题了</p>
<p>  top 的第三行数据，这一行基本上是 CPU 的一个使用情况的统计了</p>
<pre class="hljs"><code>  内容 解释
  <span class="hljs-meta">Cpu</span>(s): <span class="hljs-number">1.0</span>%us 用户空间进程占用<span class="hljs-meta">CPU</span>百分比
  <span class="hljs-number">1.0</span>% sy 内核空间运行占用<span class="hljs-meta">CPU</span>百分比
  <span class="hljs-number">0.0</span>%ni 用户进程空间内改变过优先级的进程占用<span class="hljs-meta">CPU</span>百分比
  <span class="hljs-number">97.9</span>%id 空闲<span class="hljs-meta">CPU</span>百分比
  <span class="hljs-number">0.0</span>%wa 等待输入输出的<span class="hljs-meta">CPU</span>时间百分比
  <span class="hljs-number">0.1</span>%hi 硬中断(Hardware IRQ)占用<span class="hljs-meta">CPU</span>的百分比
  <span class="hljs-number">0.0</span>%si 软中断(Software IRQ)占用<span class="hljs-meta">CPU</span>的百分比
  <span class="hljs-number">0.0</span>%st (Steal time) 是 hypervisor 等虚拟服务中，虚拟 <span class="hljs-meta">CPU</span> 等待实际 <span class="hljs-meta">CPU</span> 的时间的百分比</code></pre><p>  top 的第四行数据，这一行基本上是内存的一个使用情况的统计了：</p>
<pre class="hljs"><code>  内容 解释
  <span class="hljs-number">8176740</span> total 物理内存总量
  <span class="hljs-number">8032104</span> used 使用的物理内存总量
  <span class="hljs-number">144636</span> free 空闲内存总量
  <span class="hljs-number">313088</span> buffers 用作内核缓存的内存量</code></pre><p>  top 的第五行数据，这一行基本上是交换区的一个使用情况的统计了</p>
<pre class="hljs"><code>  内容 解释
  total 交换区总量
  used 使用的交换区总量
  <span class="hljs-built_in">free</span> 空闲交换区总量
  cached 缓冲的交换区总量,内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖</code></pre><p>  对于每个进程</p>
<pre class="hljs"><code>  列名 解释
  PID 进程id
  USER 该进程的所属用户
  PR 该进程执行的优先级 priority 值
  NI 该进程的 nice 值
  VIRT 该进程任务所使用的虚拟内存的总数
  RES 该进程所使用的物理内存数，也称之为驻留内存数
  SHR 该进程共享内存的大小
  S 该进程进程的状态: S=sleep R=running Z=zombie
<span class="hljs-tag">  %<span class="hljs-selector-tag">CPU</span></span> 该进程CPU的利用率
<span class="hljs-tag">  %<span class="hljs-selector-tag">MEM</span></span> 该进程内存的利用率
  TIME+ 该进程活跃的总时间
  COMMAND 该进程运行的名字</code></pre><p>  NICE 值叫做静态优先级，是用户空间的一个优先级值，其取值范围是-20至19。这个值越小，表示进程”优先级”越高，而值越大“优先级”越低。nice值中的 -20 到 19，中 -20 优先级最高， 0 是默认的值，而 19 优先级最低</p>
<p>  PR 值表示 Priority 值叫动态优先级，是进程在内核中实际的优先级值，进程优先级的取值范围是通过一个宏定义的，这个宏的名称是 MAX_PRIO，它的值为 140。Linux 实际上实现了 140 个优先级范围，取值范围是从 0-139，这个值越小，优先级越高。而这其中的 0 - 99 是实时进程的值，而 100 - 139 是给用户的。</p>
<p>  其中 PR 中的 100 to 139 值部分有这么一个对应 PR = 20 + (-20 to +19)，这里的 -20 to +19 便是nice值，所以说两个虽然都是优先级，而且有千丝万缕的关系，但是他们的值，他们的作用范围并不相同</p>
<p>  VIRT 任务所使用的虚拟内存的总数，其中包含所有的代码，数据，共享库和被换出 swap空间的页面等所占据空间的总数</p>
</li>
<li><p><code>ps</code> , 状态D 是不能被中断睡眠的状态，处在这种状态的进程不接受外来的任何 signal，所以无法使用 kill 命令杀掉处于D状态的进程，无论是 kill，kill -9 还是 kill -15，一般处于这种状态可能是进程 I/O 的时候出问题了</p>
</li>
<li><code>pstree</code> 可以很直接的看到相同的进程数量，最主要的还是我们可以看到所有进程的之间的相关性</li>
<li><code>kill</code> 命令发送信号给进程</li>
<li>进程的执行顺序<ul class="list">
<li>靠该进程的优先级值来判定唤醒处于休眠状态的进程的顺序</li>
<li>优先级的值就是上文所提到的 PR 与 nice 来控制与体现，nice 的值我们是可以通过 nice 命令来修改的</li>
</ul>
</li>
</ul>
<h2 id="21-linux-日志系统"><a class="header-link" href="#21-linux-日志系统"></a>21  Linux 日志系统</h2>
    </article>
  </body>
</html>
